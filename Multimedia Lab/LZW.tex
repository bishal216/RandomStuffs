\documentclass[12pt]{article}


\usepackage[utf8]{inputenc}
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[nodayofweek]{datetime}
\usepackage{tabularx}
\usepackage[small]{titlesec}
\usepackage{graphicx}
\usepackage{tabularx}

\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}

\begin{document}

\begin{titlepage}
    \begin{center}
        \huge{\bfseries  Tribhuvan University}\\
        \Large{Institute of Engineering}\\
        \huge{ \bfseries  Pulchowk Campus}\\[3.2cm]


        \textsc{\Large Multimedia System}\\[-0.5cm]
        \line(1,0){400}\\
        \huge{\bfseries LZW Compression Algorithm}\\
        \line(1,0){400}\\


        \textsc{\Large Submitted by:}\\
        \Large Bishal Katuwal\\ \large 075BCT028\\    [0.85cm]

        \textsc{\Large Submitted to:}\\\
        \large Department of Electronics and Computer Engineering\\Pulchowk Campus\\    [0.85cm]
        
        \textsc{\Large Submitted on:}\\
        \today
        
    \end{center}
\end{titlepage}
\pagebreak
% ===============================================================
\paragraph{Title\\}
LZW Algorithm
\paragraph{Background Theory\\}
LZW compression is a lossless data compression method.
It was invented by Abraham Lempel, Jacob Ziv and Terry Welch in 1984.
The name LZW stands for their names, Lempel(L), Ziv(Z) and Welch(W).
It is widely used in modern computer systems, mostly in compressing text files.

The basic idea behind LZW compression is to replace repeated sequences of data with a code that represents that sequence.
The working of LZW compression can be summarized in following two steps:\\
\subsection*{Algorithm}
For compression:
\begin{enumerate}
    \item Initialize a dictionary with all possible input characters as keys.
    \item Read in the input data stream, one character at a time.
    \item Initialize an empty string and empty output.
    \item For each character in stream:
    \begin{enumerate}
        \item Append the character in current string.
        \item Check if the current string is in dictionary.
        \begin{itemize}
            \item If the current is in the dictionary, add next characters from the stream to the dictionary until the string is no longer in the dictionary.
            \item If not, add the string to dictionary and output and reset the string to last character of previous string.
        \end{itemize}
    \end{enumerate}
    \item Output the code for the final string.
\end{enumerate}
For decompression:
\begin{enumerate}
    \item Initialize a dictionary with all possible input characters' ASCII as keys.
    \item Read in the code stream, one code at a time.
    \item Initialize a output string with first code's dictionary value.
    \item For each code in stream :
    \begin{itemize}
        \item If the code is in the dictionary, look up the corresponding character and append it to the output string.
        \item  If not, it represents a combination of the previous code and the first character of the current string. Look up the previous code and the first character of the current string in the dictionary to obtain the corresponding character sequence. Append this sequence to the output string and add it to the dictionary as a new code.
    \end{itemize}
    \item  Output the final string.
\end{enumerate}
The main advantage of the LZW algorithm is that it adapts to the data being compressed. This means that the size of the dictionary can grow as new codes are added, allowing for better compression of data with repetitive patterns.

\paragraph{Python Code}
\begin{verbatim}
# LZW compression
def compress(data):
    dictionary = {chr(i) : i for i in range(256)}
    pattern = ""
    output = []
    for char in data:
        if pattern + char in dictionary:
            pattern = pattern + char
        else:
            output.append(dictionary[pattern])
            dictionary[pattern + char] = len(dictionary)
            pattern = char      
    output.append(dictionary[pattern])
    return output
def decompress(data):
    dictionary = {i : chr(i) for i in range(256)}
    current = data[0]
    output = dictionary[current]
    for i,code in enumerate(data[1:]):
        if code in dictionary:
            temp = dictionary[code]
        else:
            temp = dictionary[current] + dictionary[current][0]
        output += temp
        # print(output)
        dictionary[len(dictionary)] = dictionary[current] + temp[0]
        current = code
    return output
def LZW(input) :
    print('The input string is '+ input +' with length ' + str(len(input)))
    encoded = compress(input)
    print('The encoded stream is '+ str(encoded)+' with length ' + str(len(encoded)))
    decoded = decompress(encoded)
    print('The decoded stream is '+ str(decoded))
def main():
    LZW('This string has no repeated pattern.')
    LZW('sadsadsadsad')
    
if __name__ == '__main__':
    main()
\end{verbatim}
\paragraph{Output}
For 'This string has no repeated pattern.'
\begin{verbatim}
The input string is This string has no repeated pattern. with length 36
The encoded stream is [84, 104, 105, 115, 32, 115, 116, 114, 105, 110, 103, 32, 104, 97, 259, 110, 
    111, 32, 114, 101, 112, 101, 97, 116, 101, 100, 32, 112, 278, 279, 114, 110
    , 46] with length 33
The decoded stream is This string has no repeated pattern.
\end{verbatim}
For 'sadsadsadsad'
\begin{verbatim}
The input string is sadsadsadsad with length 12
The encoded stream is [115, 97, 100, 256, 258, 257, 259] with length 7
The decoded stream is sadsadsadsad
\end{verbatim}
\paragraph{Conclusion\\}
In conclusion, LZW compression algorithm is a powerful lossless compression method. 
It works by building a dictionary of patterns and encoding the input data as a sequence of codes that reference the patterns in the dictionary. 
As a dynamic encoding technique, LZW also has no upper limit to number or size of codes, thus for a large system it may consume large memory.
Also, the algorithm is subject to some patent restrictions. 
Overall, the LZW algorithm is a widely used and valuable tool for lossless data compression.
\end{document}